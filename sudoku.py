# -*- coding: utf-8 -*-
"""sudoku3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jKBYvYAS692ijQshICYtdPC_pDQewkAy
"""

###############################################################################
#
# Sudoku Solver
#
# Zach Bogart, Max Torke
# 07/2018
#
# Sudoku Solver/Editor made with Python
#
###############################################################################


###############################################################################
# IMPORTS
###############################################################################

import numpy as np


###############################################################################
# PUZZLE BOARDS
###############################################################################

# hard
puzzle_comp_2018 = np.array([[0,3,0,0,4,0,0,0,0],
                         [0,0,5,1,0,0,0,8,9],
                         [0,0,0,0,0,2,7,0,0],
                         [0,0,0,9,1,0,0,0,0],
                         [0,9,4,0,0,0,3,6,0],
                         [0,0,0,0,2,3,0,0,0],
                         [0,0,6,8,0,0,0,0,0],
                         [8,2,0,0,0,9,4,0,0],
                         [0,0,0,0,5,0,0,1,0]])

puzzle_comp_2017 = np.array([[0,9,0,0,0,2,0,0,3],
                             [0,0,2,0,5,0,0,9,0],
                             [0,0,0,3,0,0,7,0,0],
                             [5,0,0,9,0,0,8,0,0],
                             [0,3,0,0,0,0,0,2,0],
                             [0,0,1,0,0,8,0,0,4],
                             [0,0,4,0,0,1,0,0,0],
                             [0,6,0,0,9,0,2,0,0],
                             [1,0,0,8,0,0,0,5,0]])

# easy
puzzle_online_easy = np.array([[0,3,2,0,9,1,0,5,4],
                         [0,0,0,0,0,0,0,0,3],
                         [1,5,0,3,4,0,9,0,7],
                         [0,0,4,0,0,7,0,8,9],
                         [3,2,0,0,6,0,0,0,1],
                         [9,0,1,0,0,0,0,0,0],
                         [4,0,0,6,0,0,7,0,2],
                         [0,0,0,2,0,3,0,0,0],
                         [0,8,0,0,1,4,0,0,5]])

# solved
puzzle_testing_solved = np.array([[8,3,2,7,9,1,6,5,4],
                         [7,4,9,5,2,6,8,1,3],
                         [1,5,6,3,4,8,9,2,7],
                         [5,6,4,1,3,7,2,8,9],
                         [3,2,8,4,6,9,5,7,1],
                         [9,7,1,8,5,2,4,3,6],
                         [4,1,3,6,8,5,7,9,2],
                         [6,9,5,2,7,3,1,4,8],
                         [2,8,7,9,1,4,3,6,5]])

# broken
puzzle_testing_too_many_nines = np.array([[0,3,2,0,9,1,0,5,4],
                         [0,9,0,0,0,0,9,0,3],
                         [1,5,0,3,4,0,9,0,7],
                         [0,0,4,0,0,7,0,8,9],
                         [3,2,0,0,6,0,0,0,1],
                         [9,0,1,0,0,0,0,0,0],
                         [4,0,0,6,0,0,7,0,2],
                         [0,0,0,2,0,3,9,0,0],
                         [0,9,0,0,1,4,0,0,5]])


###############################################################################
# CLASSES
###############################################################################

class SudokuBoard:
    '''
        Defines the sudoku board object

        Default
            - init: defines board property
        Getters
            - display(): prints board to screen (prettified)
            - get_board(): get access to board property
            - get_box_values(cell_row, cell_col): access all values in current box
            - get_row_values(row): access all values in current row
            - get_col_values(col): access all values in current col
            - get_cell_value(row, col): get desired cell's value
            - is_board_finished(): returns bool for whether board is solved or not
            - get_newest_number(): returns newest number added to board
        Setters
            - set_cell_value(row, col, val): set desired cell to val
            - set_newest_number_values(row, col, val): set newest number to desired location and value
    '''

    # define board and newest addition info
    def __init__(self, board):
        self.board = board
        self.newest_number = None
        self.newest_number_row = None
        self.newest_number_col = None

    # print board to screen
    def display(self):
        for row in range(9):
            #Draw horizontal line between each set of 3 numbers in columns
            if row % 3 == 0:
                print ("-------------------------")

            print ("|", end='')
            #Add rows of numbers
            for column in range(9):
                if(self.board[row, column] != 0):
                    # color the newest number so it stands out
                    if self.newest_number and self.newest_number_row == row and self.newest_number_col == column:
                        print('\033[95m' + " " + str(self.board[row, column]) + '\033[0m', end='')
                        self.newest_number = None
                    # normal color
                    else:
                        print(" " + str(self.board[row, column]), end='')
                else:
                    print(" -", end='')
            #Draw vertical lines between each set of 3 numbers in rows
                if (column%3 == 2):
                    print (" |", end='')
            print ("")
        print ("-------------------------\n")

        return

    # get access to board
    def get_board(self):
        return self.board

    # get box values for desired cell
    def get_box_values(self, cell_row, cell_col):
        '''
            returns all cell values in a given cell's square
        '''
        BoxCoord_row = cell_row//3
        BoxCoord_col = cell_col//3

        BoxVals = []
        for BoxPos_row in range(3):
            for BoxPos_col in range(3):
                Coord_row = 3*BoxCoord_row + BoxPos_row
                Coord_col = 3*BoxCoord_col + BoxPos_col
                Value = self.board[Coord_row][Coord_col]
                if (Value != 0):
                    BoxVals.append(Value)

        return BoxVals

    # get row values for desired cell
    def get_row_values(self, row):
        '''
            returns all cell values in a given row
        '''
        RowVals = list(self.board[row,:])

    #     print ("RowValues:  " + str(RowVals))
        return RowVals

    # get col values for desired cell
    def get_col_values(self, col):
        '''
            returns all cell values in a given column
        '''

        ColumnVals = list(self.board[:,col])

    #     print ("ColumnValues:  " + str(ColumnVals))
        return ColumnVals

    # get cell value
    def get_cell_value(self, row, col):
        return self.board[row, col]

    # check if board is finished
    def is_board_finished(self):
        '''
            Checks board is validly solved
        '''
        # check about duplicates
        def there_are_duplicates(nums):
            return len(nums) != len(set(nums))

        cooordinates = range(9)
        boxes = [[1,1], [1,4], [1,7],
                 [4,1], [4,4], [4,7],
                 [7,1], [7,4], [7,7]]
        digits = range(1,10)

        # dumb check for no blanks
        for row in cooordinates:
            for col in cooordinates:
                if self.board[row, col].any() == 0:
                    return False

        # check boxes
        for box in boxes:
            # get box values from board
            nums = self.get_box_values(box[0], box[1])
            # check about duplicates
            if there_are_duplicates(nums):
                print("Error: Duplicate Detected in a Box (>_<)")
                return False
            # if box values do not contain all digits, say no
            if set(nums) != set(digits):
                return False

        # check rows
        for row in cooordinates:
            # get row values from board
            nums = self.get_row_values(row)
            # check about duplicates
            if there_are_duplicates(nums):
                print("Error: Duplicate Detected in a Row (>_<)")
                return False
            # if row values do not contain all digits, say no
            if set(nums) != set(digits):
                return False

        # check cols
        for col in cooordinates:
            # get col values from board
            nums = self.get_col_values(col)
            # check about duplicates
            if there_are_duplicates(nums):
                print("Error: Duplicate Detected in a Column (>_<)")
                return False
            # if col values do not contain all digits, say no
            if set(nums) != set(digits):
                return False

        # got all the way with no faults, so done
        return True

    # get newest addition to board
    def get_newest_number(self):
        return self.newest_number

    # set value for selected cell
    def set_cell_value(self, row, col, val):
        self.board[row, col] = val

    # set value of most recently added number
    def set_newest_number_values(self, row, col, val):
        self.newest_number = val
        self.newest_number_row = row
        self.newest_number_col = col

class CellOptions:
    '''
        Defines the options for every cell on board

        Default
            - init: defines options property with input board's starting values
        Getters
            - display(): prints options to screen
            - get_options_for_cell(row, col): returns options for desired cell
            - get_num_options_for_cell(row, col): returns number of options for desired cell
        Setters
            - remove_option_for_cell(row, col, val): remove val from desired cell's options
    '''

    # define options
    def __init__(self, sudoku_board):

        '''
            create large array of possibilities for every cell
            atom://teletype/portal/1fe8b177-e0ed-48b5-b2fd-933428e13572
        '''

        # fill value array
        # options = [[[0 for x in range(9)]for y in range(9)]for z in range(9)]
        options = np.zeros((9,9,9))
        # options[:] = [1,2,3,4,5,6,7,8,9]

        for row in range(9):
            for col in range(9):
                # if cell is undecided, included all values
                if sudoku_board[row, col] == 0:
                    for item in range(9):
                        options[row, col, item] = item + 1
                # if cell is decided, set it to that value
                else:
                    options[row, col] = [sudoku_board[row, col]]

        self.options = options

    # print out all options
    def display(self):
        print(self.options)

    # returns options for desired cell
    def get_options_for_cell(self, row, col):
        return self.options[row, col][self.options[row, col] != 0]

    # returns options for desired box
    def get_box_options(self, row, col):
        return self.options[row, col][self.options[row, col] != 0]

    # returns options for desired row
    def get_row_options(self, row, col):
        return self.options[row, :][self.options[row, :] != 0]

    # returns options for desired column
    def get_col_options(self, row, col):
        return self.options[:,col][self.options[:,col] != 0]

    # returns number of options for desired cell
    def get_num_options_for_cell(self, row, col):
        # return len(self.options[row, col])
        return np.count_nonzero(self.options[row, col])

    # remove option from desired cell
    def remove_option_for_cell(self, row, col, val):
        self.options[row, col, val-1] = 0


###############################################################################
# ANALYSIS METHODS
###############################################################################

def immediate_neighbor_elimination(choices, sudoku):
    '''
        update possible values for every cell
        using dumb immediate elimination
            - look at the row, col, and box the cell is in
            - rule out those possibilities
            - if done to one, add to board

        Return:
            - return_code:
                0: no progress
                1: reduced options, no board placement
                2: reduced options + board placement
            - made_progress:
                True: removed possibilities/placed number on board
                False: nothing reduced/placed
            - location:
                (cell_row, cell_col): tuple of newest number addition to board
    '''
    # flag for choices
    choices_removed = 0

    # loop thru all cells
    for cell_row in range(9):
        for cell_col in range(9):
            # get all neighbors by row/col/box
            box = sudoku.get_box_values(cell_row,cell_col)
            col = sudoku.get_col_values(cell_col)
            row = sudoku.get_row_values(cell_row)

            # combine neighbors to unique list
            all_three = np.concatenate([row, col, box])
            all_three = list(np.unique(all_three))
            # remove current cell value from the group
            all_three.remove(sudoku.get_cell_value(cell_row, cell_col))

            # remove possibilites
            for rmv_num in all_three:
                # if it's still an option, remove it
                if rmv_num in choices.get_options_for_cell(cell_row, cell_col):
                    choices.remove_option_for_cell(cell_row, cell_col, rmv_num)
                    choices_removed += 1
                    # if down to only one choice, add it to the board and return
                    if choices.get_num_options_for_cell(cell_row, cell_col) == 1:
                        new_number = choices.get_options_for_cell(cell_row, cell_col)[0]
                        sudoku.set_cell_value(cell_row, cell_col, new_number)

                        # make this value bold for printing
                        sudoku.set_newest_number_values(cell_row, cell_col, new_number)

                        return 2, True, (cell_row, cell_col)

    # at this point, nothing was added to board

    # if removed any choices, report progress was made
    if choices_removed > 0:
        # reset newest number
        sudoku.set_newest_number_values(None, None, None)

        return 1, True, None
    # otherwise, say no progress was made
    else:
        # reset newest number
        sudoku.set_newest_number_values(None, None, None)

        return 0, False, None


###############################################################################
# TODO
###############################################################################

def region_possibilities_func(cell_row, cell_col, cell_possibilities, region):
    '''
    return a list containing a list of all possible numbers in each cell
    '''
    if region == "row":
        return cell_possibilities[cell_row].copy()

    elif region == "col":
        return [item[cell_col] for item in cell_possibilities]

    elif region == "box":

        BoxCoord_row = cell_row//3
        BoxCoord_col = cell_col//3

        region_possibilities = []
        for BoxPos_row in range(3):
            for BoxPos_col in range(3):
                Coord_row = 3*BoxCoord_row + BoxPos_row
                Coord_col = 3*BoxCoord_col + BoxPos_col
                Value = cell_possibilities[Coord_row][Coord_col]
                region_possibilities.append(Value)
        return region_possibilities

def neighbor_elimination_box(choices, sudoku):
    '''
        Update cell possibilities using neighboring cell values in
        associated row/col/box


    '''

    # loop thru all cells
    for cell_row in range(9):
        for cell_col in range(9):
            region_possibilities = sudoku.get_box_values(cell_row, cell_col)
            region_possibilities.remove(sudoku.get_cell_value(cell_row, cell_col))




#     region_possibilities = sudoku.

    region_possibilities = region_possibilities_func(cell_row, cell_col, cell_possibilities, region)
    region_possibilities.pop( 3*(cell_row%3) + cell_col%3 ) #remove possibilities of cell being checked


###############################################################################
# USER STATUS-UPDATE
###############################################################################

# give wordy result for user output
def write_cell_location_in_words(location):
    words = {
        0: "First",
        1: "Second",
        2: "Third",
        3: "Fourth",
        4: "Fifth",
        5: "Sixth",
        6: "Seventh",
        7: "Eighth",
        8: "Ninth"
    }
    return words[location[0]], words[location[1]]

# give user update on what was changed
def respond_to_return_code(code, analysis_type, sudoku, location):
    if code == 0:
        print(analysis_type + ": No progress made (._.)")
    elif code == 1:
        print(analysis_type + ": Removed Possibilities ('_')")
    elif code == 2:
        row, col = write_cell_location_in_words(location)
        print(analysis_type + ": Added a number (^_^)" +
              "\n  " + str(row) + " Row, " + str(col) + " Column")
        sudoku.display()


###############################################################################
# MAIN
###############################################################################

def main(board = puzzle_online_easy):

    # setup board and choices objects
    sudoku = SudokuBoard(board)
    options = CellOptions(sudoku.get_board())

    # display board initially
    sudoku.display()

    # define flags for progress and return values
    made_progress = True
    return_code = 1

    # define method calls and formatting
    method_names = {immediate_neighbor_elimination: "Simple Elimination"}
    methods = method_names.keys()


    # while making progress and unsolved, go thru analysis methods
    while made_progress:
        '''
            - 0: no progress made
            - 1: removed possibilities but no num placed
            - 2: num placed on board/removed possibilities
        '''
        # loop thru methods, check if progress is made
        for method in methods:
            return_code, made_progress, location = method(options, sudoku)
            respond_to_return_code(return_code, method_names[method], sudoku, location)
            if return_code > 0:
                break

    # at this point, no progress was made using all methods

    # if board is solved, say so
    if sudoku.is_board_finished():
        print("\nSOLVED ＼(^o^)／")
    # otherwise, unable to solve this one
    else:
        print("\nCould not solve (>_<)")

    # display board
    sudoku.display()

if __name__ == "__main__":
    main()
