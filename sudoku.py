# -*- coding: utf-8 -*-
"""sudoku3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jKBYvYAS692ijQshICYtdPC_pDQewkAy
"""

###############################################################################
#
# Sudoku Solver
#
# Zach Bogart, Max Torke
# 07/2018
#
# Sudoku Solver/Editor made with Python
#
###############################################################################


###############################################################################
# IMPORTS
###############################################################################

import numpy as np


###############################################################################
# PUZZLE BOARDS
###############################################################################

# hard
puzzle_comp_2018 = np.array([[0,3,0,0,4,0,0,0,0],
                         [0,0,5,1,0,0,0,8,9],
                         [0,0,0,0,0,2,7,0,0],
                         [0,0,0,9,1,0,0,0,0],
                         [0,9,4,0,0,0,3,6,0],
                         [0,0,0,0,2,3,0,0,0],
                         [0,0,6,8,0,0,0,0,0],
                         [8,2,0,0,0,9,4,0,0],
                         [0,0,0,0,5,0,0,1,0]])

puzzle_comp_2017 = np.array([[0,9,0,0,0,2,0,0,3],
                             [0,0,2,0,5,0,0,9,0],
                             [0,0,0,3,0,0,7,0,0],
                             [5,0,0,9,0,0,8,0,0],
                             [0,3,0,0,0,0,0,2,0],
                             [0,0,1,0,0,8,0,0,4],
                             [0,0,4,0,0,1,0,0,0],
                             [0,6,0,0,9,0,2,0,0],
                             [1,0,0,8,0,0,0,5,0]])

# easy
puzzle_online_easy = np.array([[0,3,2,0,9,1,0,5,4],
                         [0,0,0,0,0,0,0,0,3],
                         [1,5,0,3,4,0,9,0,7],
                         [0,0,4,0,0,7,0,8,9],
                         [3,2,0,0,6,0,0,0,1],
                         [9,0,1,0,0,0,0,0,0],
                         [4,0,0,6,0,0,7,0,2],
                         [0,0,0,2,0,3,0,0,0],
                         [0,8,0,0,1,4,0,0,5]])

# solved
puzzle_testing_solved = np.array([[8,3,2,7,9,1,6,5,4],
                         [7,4,9,5,2,6,8,1,3],
                         [1,5,6,3,4,8,9,2,7],
                         [5,6,4,1,3,7,2,8,9],
                         [3,2,8,4,6,9,5,7,1],
                         [9,7,1,8,5,2,4,3,6],
                         [4,1,3,6,8,5,7,9,2],
                         [6,9,5,2,7,3,1,4,8],
                         [2,8,7,9,1,4,3,6,5]])

# broken
puzzle_testing_too_many_nines = np.array([[0,3,2,0,9,1,0,5,4],
                         [0,9,0,0,0,0,9,0,3],
                         [1,5,0,3,4,0,9,0,7],
                         [0,0,4,0,0,7,0,8,9],
                         [3,2,0,0,6,0,0,0,1],
                         [9,0,1,0,0,0,0,0,0],
                         [4,0,0,6,0,0,7,0,2],
                         [0,0,0,2,0,3,9,0,0],
                         [0,9,0,0,1,4,0,0,5]])


###############################################################################
# CLASSES
###############################################################################

class SudokuBoard:
    '''
        Defines the sudoku board object
    '''

    # define board and newest addition info
    def __init__(self, board):
        self.board = board
        self.newest_number_row = None
        self.newest_number_col = None

    # print board to screen
    def display(self):
        for row in range(9):
            #Draw horizontal line between each set of 3 numbers in columns
            if row % 3 == 0:
                print ("-------------------------")

            print ("|", end='')
            #Add rows of numbers
            for column in range(9):
                if(self.board[row, column] != 0):
                    # color the newest number so it stands out
                    if self.newest_number_row == row and self.newest_number_col == column:
                        print('\033[95m' + " " + str(self.board[row, column]) + '\033[0m', end='')
                    # normal color
                    else:
                        print(" " + str(self.board[row, column]), end='')
                else:
                    print(" -", end='')
            #Draw vertical lines between each set of 3 numbers in rows
                if (column%3 == 2):
                    print (" |", end='')
            print ("")
        print ("-------------------------\n")

        return

    # get access to board
    def get_board(self):
        return self.board

    # get box values for desired cell
    def get_box_values(self, cell_row, cell_col):
        '''
            returns all cell values in a given cell's square
        '''
        box_coord_row = cell_row//3
        box_coord_col = cell_col//3

        box_vals = []
        for box_pos_row in range(3):
            for box_pos_col in range(3):
                coord_row = 3*box_coord_row + box_pos_row
                coord_col = 3*box_coord_col + box_pos_col
                value = self.board[coord_row][coord_col]
                box_vals.append(value)

        return box_vals

    # get row values for desired cell
    def get_row_values(self, row):
        '''
            returns all cell values in a given row
        '''
        row_vals = list(self.board[row,:])

        return row_vals

    # get col values for desired cell
    def get_col_values(self, col):
        '''
            returns all cell values in a given column
        '''

        column_vals = list(self.board[:,col])

        return column_vals

    # get cell value
    def get_cell_value(self, row, col):
        return self.board[row, col]

    # checks board is valid (no duplicates)
    def is_board_valid(self, printing):
        '''
            Checks board is a valid starting board
            - Subroutine for is_board_finished to check end state
        '''
        # check about duplicates
        def there_are_duplicates(nums):
            return len(set(nums)) != len(nums)

        cooordinates = range(9)
        boxes = [[1,1], [1,4], [1,7],
                 [4,1], [4,4], [4,7],
                 [7,1], [7,4], [7,7]]

        # check boxes
        for box in boxes:
            # get box values from board
            nums = self.get_box_values(box[0], box[1])
            nums[:] = [x for x in nums if x != 0]
            # check about duplicates
            if there_are_duplicates(nums):
                print('\033[91m' + " " + "Error: Duplicate Detected in a Box (>_<)" + '\033[0m')
                return False

        # check rows
        for row in cooordinates:
            # get row values from board, removing blanks
            nums = self.get_row_values(row)
            nums[:] = [x for x in nums if x != 0]
            # check about duplicates
            if there_are_duplicates(nums):
                print('\033[91m' + " " + "Error: Duplicate Detected in a Row (>_<)" + '\033[0m')
                return False

        # check cols
        for col in cooordinates:
            # get col values from board
            nums = self.get_col_values(col)
            nums[:] = [x for x in nums if x != 0]
            # check about duplicates
            if there_are_duplicates(nums):
                print('\033[91m' + " " + "Error: Duplicate Detected in a Column (>_<)" + '\033[0m')
                return False

        # got all the way with no faults, so done
        if printing:
            # let user know if desired
            print('\033[92m' + "Valid starting board (^_^)" + '\033[0m')

        return True

    # check if board is finished (no blanks AND no duplicates)
    def is_board_finished(self):
        '''
            Checks board is validly solved (no blanks and no duplicates)
        '''
        # dumb check for no blanks
        if 0 in self.board:
            return False

        return self.is_board_valid(printing=False)

    # set value for selected cell
    def set_cell_value(self, row, col, val):
        self.board[row, col] = val

    # set value of most recently added number
    def set_newest_number_values(self, row, col):
        self.newest_number_row = row
        self.newest_number_col = col

class CellOptions:
    '''
        Defines the options for every cell on board
    '''

    # define options
    def __init__(self, sudoku_board):

        '''
            create large array of possibilities for every cell
        '''

        # fill value array
        options = np.zeros((9,9,9), dtype=int)
        options[:] = [1,2,3,4,5,6,7,8,9]

        for row in range(9):
            for col in range(9):
                # if cell is decided, remove all values from array
                current_val = sudoku_board[row,col]
                if current_val != 0:
                    options[row,col,:] = 0

        self.options = options

    # print out all options
    def display(self):
        print(self.options)

    # returns options for desired cell
    def get_options_for_cell(self, row, col):
        return self.options[row, col][self.options[row, col] != 0]

    # returns options for desired cell
    def get_options_for_cell_with_zeros(self, row, col):
        return self.options[row, col]

    # returns (9x9x9) array of cell options
    def get_all_options_array(self):
        return self.options

    # returns options for desired row
    def get_row_options_array(self, row):
        return self.options[row, :]

    # returns options for desired column
    def get_col_options_array(self, col):
        return self.options[:,col]

    # returns options for desired box
    def get_box_options_array(self, cell_row, cell_col):
        box_coord_row = cell_row//3
        box_coord_col = cell_col//3

        box_options = np.zeros((1,9), dtype=int)
        for box_pos_row in range(3):
            for box_pos_col in range(3):
                coord_row = 3*box_coord_row + box_pos_row
                coord_col = 3*box_coord_col + box_pos_col
                newvals = self.get_options_for_cell_with_zeros(coord_row,coord_col).reshape((1,9))
                box_options = np.concatenate((box_options,newvals), axis=0)

        return box_options[1:]

    # returns number of options for desired cell
    def get_num_options_for_cell(self, row, col):
        # return len(self.options[row, col])
        return np.count_nonzero(self.options[row, col])

    # remove option from desired cell
    def remove_option_for_cell(self, row, col, val):
        self.options[row, col, val-1] = 0

    # set one option, removing all other options
    def clear_all_options_for_cell(self, row, col):
        self.options[row,col,:] = 0


###############################################################################
# GENERAL METHODS
###############################################################################

# get all neighbors or only unique neighbors for given cell, excluding zero
def get_all_neighbors(cell_row, cell_col, sudoku, unique):
    box = sudoku.get_box_values(cell_row,cell_col)
    col = sudoku.get_col_values(cell_col)
    row = sudoku.get_row_values(cell_row)
    # combine neighbors into one list
    all_three = np.array(row + col + box)
    all_three = np.sort(all_three[all_three != 0])
    if unique:
        all_three = np.unique(all_three)

    return all_three

# updates the board object with addition + syntax highlighting for printing
def add_number_to_board(cell_row, cell_col, new_number, sudoku, computer_options):
        # add number to board
        sudoku.set_cell_value(cell_row, cell_col, new_number)

        # make this value bold for printing
        sudoku.set_newest_number_values(cell_row, cell_col)

# Propogate new_val through computer_options
def update_computer_options(computer_options, new_val_row, new_val_col, new_val):
    # update computer_options for all cells in new_val box
    box_row = new_val_row // 3
    box_col = new_val_col // 3

    # make cell with new value all zeros
    computer_options.options[new_val_row][new_val_col][:] = 0
    # computer_options.options[3 * box_row: 3 * box_row + 3][3 * box_col:3 * box_col + 3][new_val - 1] = 0
    # update for all cells in box
    for r in range(3):
        for c in range(3):
            computer_options.options[3*box_row+r][3*box_col+c][new_val - 1] = 0

    # update computer_options for all cells in new_val row
    for i in range(9):
        computer_options.options[i][new_val_col][new_val - 1] = 0

    # update computer_options for all cells in new_val col
    for i in range(9):
        computer_options.options[new_val_row][i][new_val-1] = 0

    return computer_options

# create collection of options the user can keep track of (with human memory)
def generate_user_options(computer_options, sudoku):
    user_options = CellOptions(sudoku.get_board())
    user_options.options[:] = computer_options.options
    # determine which cell options can be retained by a person, and replace those that can't with an array from 1-9
    for row in range(9):
        for col in range(9):
            if np.count_nonzero(user_options.get_options_for_cell_with_zeros(row,col)) > human_memory:
                user_options.options[row][col] = np.arange(1,10)
    return user_options

# create computer options (all relationships b/w cells)
def create_computer_options(sudoku):

    # create basic (9x9x9) options array containing arrays of 0's for solved cells and range(9)+1 for blank cells
    computer_options = CellOptions(sudoku.get_board())

    # loop through all cells
    for cell_row in range(9):
        for cell_col in range(9):

            # if the cell is not defined yet...
            if sudoku.get_cell_value(cell_row, cell_col) == 0:

                # get all neighbors by row/col/box
                all_three = get_all_neighbors(cell_row, cell_col, sudoku, True)

                # iterate through all numbers that are found in cell row/col/box
                for val in all_three:
                    # remove option from desired cell
                    computer_options.remove_option_for_cell(cell_row, cell_col, val)
            else:
                computer_options.clear_all_options_for_cell(cell_row, cell_col)

    return computer_options


###############################################################################
# ANALYSIS METHODS
###############################################################################

def immediate_neighbor_elimination(computer_options, user_options, sudoku):
    '''
        Use already updated user_options and computer_options to find solvable values
    '''

    # check if any computer_options arrays are of length 1, and solve a cell if so
    # loop thru all cells
    for cell_row in range(9):
        for cell_col in range(9):
            if np.count_nonzero(user_options.get_options_for_cell(cell_row, cell_col)) == 1:
                # EDIT:  NEW VALUE FOUND, INPUT INTO SUDOKU BOARD and reset run
                new_number = np.argmax(user_options.get_options_for_cell_with_zeros(cell_row, cell_col)) + 1
                return 2, (cell_row, cell_col, new_number)

    # otherwise, say no progress was made
    return 0, None

def box_elimination(computer_options, user_options, sudoku):
    # use 9x9x9 "choices_copy" array and determine if an option only appears once in a box
    for box_row in range(3):
        for box_col in range(3):

            check = np.bincount(computer_options.get_box_options_array(3*box_row, 3*box_col).flatten(), minlength = 10)
            check = np.delete(check, 0) #remove bincount of zeros
            for indx in range(9):
                if check[indx] == 1:
                    # EDIT:  ADD NEW NUMBER TO BOARD
                    box_index = np.where(computer_options.get_box_options_array(3 * box_row, 3 * box_col) == indx+1)[0]
                    row_offset = int(box_index // 3)
                    col_offset = int(box_index % 3)
                    cell_row = 3 * box_row + row_offset
                    cell_col = 3*box_col + col_offset

                    # print("Box_elimination -> Row: " + str(cell_row) + "  Col: " + str(cell_col) + "Number Added: " + str(indx+1))
                    return 2, (cell_row, cell_col, indx+1)

    # otherwise, say no progress was made
    return 0, None

def row_elimination(computer_options, user_options, sudoku):
    for row in range(9):
        check = np.bincount(computer_options.get_row_options_array(row).flatten(), minlength = 10)
        check = np.delete(check, 0) #remove bincount of zeros
        for indx in range(9):
            if check[indx] == 1:
                # EDIT:  ADD NEW NUMBER TO BOARD
                cell_row = row
                cell_col = int(np.where(computer_options.get_row_options_array(row) == indx + 1)[0])

                # print("Row_elimination -> Row: " + str(row) + "Number Added: " + str(indx+1))
                return 2, (cell_row, cell_col, indx+1)

    # otherwise, say no progress was made
    return 0, None

def col_elimination(computer_options, user_options, sudoku):
    for col in range(9):
        check = np.bincount(computer_options.get_col_options_array(col).flatten(), minlength = 10)
        check = np.delete(check, 0) #remove bincount of zeros
        for indx in range(9):
            if check[indx] == 1:
                # EDIT:  ADD NEW NUMBER TO BOARD
                cell_row = int(np.where(computer_options.get_col_options_array(col) == indx + 1)[0])
                cell_col = col

                # print("Col_elimination -> Col: " + str(col) + "Number Added: " + str(indx+1))
                return 2, (cell_row, cell_col, indx+1)

    # otherwise, say no progress was made
    return 0, None

###############################################################################
# USER STATUS-UPDATE METHODS
###############################################################################

# give wordy result for user output
def write_cell_location_in_words(location):
    words = {
        0: "First",
        1: "Second",
        2: "Third",
        3: "Fourth",
        4: "Fifth",
        5: "Sixth",
        6: "Seventh",
        7: "Eighth",
        8: "Ninth"
    }
    return words[location[0]], words[location[1]]

# give user update on what was changed
def respond_to_progress_made(code, analysis_type, sudoku, location):
    if code == 0:
        print(analysis_type + ": No progress made (._.)")
    elif code == 1:
        print(analysis_type + ": Removed Possibilities ('_')")
    elif code == 2:
        row, col = write_cell_location_in_words(location)
        print("\n" + analysis_type + ": Added a number (^_^)" + "\n  " + str(row) + " Row, " + str(col) + " Column")

###############################################################################
# TESTING BLOCK
###############################################################################

# testing = np.array([ [0,0,0,0,0,0,0,0,0],
#                      [0,0,0,0,0,0,0,0,0],
#                      [0,0,0,0,0,0,0,0,7],
#                      [0,0,0,0,0,7,0,8,9],
#                      [0,0,7,0,0,0,0,0,1],
#                      [0,0,0,0,0,0,0,0,0],
#                      [0,0,0,0,0,0,7,0,0],
#                      [0,0,0,0,0,0,0,0,0],
#                      [0,0,0,0,0,0,0,0,0]])
#
# foo = SudokuBoard(puzzle_online_easy)
# bar = CellOptions(foo.get_board())
#
# # display board initially
# foo.display()
#
#
#
# bar.display()
# immediate_neighbor_elimination(bar, foo)

###############################################################################
# MAIN
###############################################################################

### GLOBALS ###
human_memory = 2 # corresponds to the number of values a human can retain when solving the sudoku

def main(board = puzzle_comp_2018):

    # setup board and choices objects
    sudoku = SudokuBoard(board)

    # display board initially
    sudoku.display()

    # if board is not valid, return
    if not sudoku.is_board_valid(printing=True):
        return

    # define flag for progress made
    made_progress = 1

    # define analysis call order and formatting names
    method_names = {box_elimination: "Only Option in Box",
                    row_elimination: "Only Option in Row",
                    col_elimination: "Only Option in Col",
     immediate_neighbor_elimination: "Use Every Neighbor"}
    methods = method_names.keys()

    # define new number values
    new_val_row = 0
    new_val_col = 0
    new_val = 0

    # create computer/user options objects
    computer_options = create_computer_options(sudoku)
    user_options = generate_user_options(computer_options, sudoku)

    # while making progress, go thru analysis methods
    while made_progress:
        '''
            0: no progress made
            1: removed possibilities but no num placed
            2: num placed on board/removed possibilities
        '''

        # loop through methods, check if progress is made
        for method in methods:
            # run analysis method
            made_progress, new_val_info = method(computer_options, user_options, sudoku)

            # # inform user about changes
            respond_to_progress_made(made_progress, str(method_names[method]), sudoku, new_val_info)

            # if progress was made
            if made_progress > 0:
                # update new number info and options objects
                if new_val_info:
                    new_val_row, new_val_col, new_val = new_val_info[0], new_val_info[1], new_val_info[2]
                    computer_options = update_computer_options(computer_options, new_val_row, new_val_col, new_val)
                    user_options = generate_user_options(computer_options, sudoku)

                # if a new number was found, add it and display board
                if made_progress == 2:
                    add_number_to_board(new_val_row, new_val_col, new_val, sudoku, computer_options)
                    sudoku.display()

                    # if game is over, end program
                    if sudoku.is_board_finished():
                        print('\033[92m' + " " + "\nSOLVED ＼(^o^)／" + '\033[0m')
                        # display board
                        sudoku.newest_number_row, sudoku.newest_number_col = None, None  # clear newest number (to avoid highlighting) for final print
                        sudoku.display()
                        return
                break

    # at this point, no progress was made using all methods
    # unable to solve this one: display and end program
    print('\033[91m' + " " + "\nCould not solve (>_<)" + '\033[0m')
    sudoku.newest_number_row, sudoku.newest_number_col = None, None #clear newest number (to avoid highlighting) for final print
    sudoku.display()

    return


# run main by default
if __name__ == "__main__":
    main()
